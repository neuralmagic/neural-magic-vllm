"""Compare the logprobs of two sequences generated by different models,
which should be similar but not necessarily equal.
"""

import pandas as pd


def check_logprobs_close(outputs_0_lst, outputs_1_lst, name_0, name_1):

    # Loop through responses to each prompt.
    prompts_in_error = dict()
    for prompt_idx, (outputs_0,
                     outputs_1) in enumerate(zip(outputs_0_lst,
                                                 outputs_1_lst)):
        # combine the data into a single dataframe
        outputs_0_df = pd.DataFrame.from_records(outputs_0).transpose().drop(
            columns=1).dropna(axis=0,
                              how="all").rename(columns={
                                  0: f"{name_0}_tokens_index",
                                  2: f"{name_0}_keyed_logprobs"
                              })
        outputs_1_df = pd.DataFrame.from_records(outputs_1).transpose().drop(
            columns=1).dropna(axis=0,
                              how="all").rename(columns={
                                  0: f"{name_1}_tokens_index",
                                  2: f"{name_1}_keyed_logprobs"
                              })
        all_outputs_df = pd.concat([outputs_0_df, outputs_1_df],
                                   axis="columns")

        # find name_0 tokens that appear in any of the keys of the name_1
        # logprobs
        all_outputs_df[
            f"{name_0}_token_in_{name_1}_logprobs"] = all_outputs_df.apply(
                lambda row: any(kee.strip() in row[f"{name_0}_tokens_index"]
                                for kee in row[f"{name_1}_keyed_logprobs"]),
                axis=1)
        # find name_1 tokens that appear in any of the keys of the name_0
        # logprobs
        all_outputs_df[
            f"{name_1}_token_in_{name_0}_logprobs"] = all_outputs_df.apply(
                lambda row: any(kee.strip() in row[f"{name_1}_tokens_index"]
                                for kee in row[f"{name_0}_keyed_logprobs"]),
                axis=1)

        # both of the above columns have to be True for a token to match
        # "closely"
        all_outputs_df["tokens_in_error"] = ~(
            all_outputs_df[f"{name_0}_token_in_{name_1}_logprobs"]
            & all_outputs_df[f"{name_1}_token_in_{name_0}_logprobs"])

        # Record the tokens that do not match for this prompt, if any
        # TODO: should we limit this check to the first half dozen tokens,
        #  instead of the whole list?
        if any(all_outputs_df["tokens_in_error"]):
            prompts_in_error[prompt_idx] = all_outputs_df[
                all_outputs_df["tokens_in_error"]][[
                    f"{name_0}_tokens_index", f"{name_0}_keyed_logprobs",
                    f"{name_1}_tokens_index", f"{name_1}_keyed_logprobs"
                ]]

    error_message = "response for some prompts did not closely match:"
    for pidx in prompts_in_error:
        error_message = "\n".join([
            error_message, "\n", f"prompt index {pidx}",
            prompts_in_error[pidx].to_json(orient='index', indent=2)
        ])
    assert not prompts_in_error, error_message
